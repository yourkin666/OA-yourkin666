包 com.example.expence.intercepters；​​​​​​

导入 com.example.expence.utils.JwtUtil；​​​​​​​​
导入 com.example.expence.utils.ThreadLocalUtil；​​​​​​​​
导入 jakarta.servlet.http.HttpServletRequest；​​​​​​
导入 jakarta.servlet.http.HttpServletResponse；​​​​​​
导入 org.springframework.beans.factory.annotation.Autowired；​​​​​​​​​​
导入 org.springframework.data.redis.core.StringRedisTemplate；​​​​​​​​​​
导入 org.springframework.data.redis.core.ValueOperations；​​​​​​​​​​
导入 org.springframework.stereotype.Component ；​​​​​​
导入 org.springframework.web.servlet.HandlerInterceptor；​​​​​​​​
导入 org.springframework.web.servlet.ModelAndView ;​​​​​​​​

导入 java.util.Map；​​​​

@成分
公共 类 LoginIntercepter 实现 HandlerInterceptor {
    @自动装配
    私有 StringRedisTemplate 字符串RedisTemplate；
    @覆盖
    public  boolean  preHandle ( HttpServletRequest 请求, HttpServletResponse 响应, Object  handler )抛出 异常{
// 从请求头中拿 token
        String  token =请求.getHeader ( "授权" ) ;
        尝试{
// 从redis中拿token
            ValueOperations < String，String > operations = stringRedisTemplate . opsForValue ();
            字符串 redisToken =操作.get ( token ) ;
// 没有token进不去
            如果（redisToken == null）{
                抛出 新的 RuntimeException（）；
            }
//把token解析后存入线程，以后想用其中的信息，可以自取
            Map < String , Object > claims = JwtUtil . parseToken ( token );
            ThreadLocalUtil .设置（声明）；
            返回 true；
        }捕获（异常 e）{
//报401错误
            回复。设置状态（401）；
            返回 false；
        }

    }

    @覆盖
    public  void  postHandle ( HttpServletRequest 请求, HttpServletResponse 响应, Object  handler , ModelAndView  modelAndView )抛出 异常{
        HandlerInterceptor . super . postHandle (请求,响应,处理程序, modelAndView );
    }

    @覆盖
    public  void  afterCompletion ( HttpServletRequest 请求, HttpServletResponse 响应, Object  handler , Exception  ex )抛出 异常{
        HandlerInterceptor . super . afterCompletion (请求,响应,处理程序, ex );
    }
}
